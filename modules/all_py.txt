===== FILE: C:\Users\Home\Desktop\Nova pasta (5)\SolarScan-MVP\modules\analise.py =====

"""
MÃ³dulo para anÃ¡lise de impacto da geraÃ§Ã£o distribuÃ­da na rede elÃ©trica.

Upgrade (metodologia):
- Sai de "contagem pura" e passa a estimar potÃªncia (kW) com heurÃ­stica:
  - Se a detecÃ§Ã£o tiver bbox + zoom + tamanho do tile => estima Ã¡rea (mÂ²) e converte para kW
  - Caso contrÃ¡rio => usa kW mÃ©dio por detecÃ§Ã£o (default)
- Cruza com heurÃ­sticas de carga (perfil residencial/comercial/industrial) para estimar penetraÃ§Ã£o.
"""

from __future__ import annotations

import math
from typing import Any, Dict, List, Optional


# -----------------------------
# PotÃªncia estimada (heurÃ­stica)
# -----------------------------

def _meters_per_pixel_webmercator(lat: float, zoom: int) -> float:
    # WebMercator: metros por pixel em funÃ§Ã£o de lat e zoom
    R = 6378137.0
    return (math.cos(math.radians(float(lat))) * 2.0 * math.pi * R) / (256.0 * (2.0 ** int(zoom)))


def _bbox_area_m2(det: Dict[str, Any]) -> Optional[float]:
    """
    Estima Ã¡rea (mÂ²) do bbox com base em pixels e metros/pixel.

    Requer:
      - tile_zoom, tile_img_w, tile_img_h, tile_lat
      - bbox ou x/y/width/height (ou x1..y2)

    Obs: Ã¡rea de bbox Ã© uma proxy â€” nÃ£o representa Ã¡rea real de mÃ³dulos,
    mas jÃ¡ dÃ¡ ordem de grandeza para metodologia.
    """
    zoom = det.get("tile_zoom")
    lat = det.get("tile_lat")
    img_w = det.get("tile_img_w")
    img_h = det.get("tile_img_h")

    if zoom is None or lat is None or img_w is None or img_h is None:
        return None

    # bbox em px
    x1y1x2y2 = None
    for k in ("bbox", "xyxy", "box"):
        v = det.get(k)
        if isinstance(v, (list, tuple)) and len(v) == 4:
            try:
                x1, y1, x2, y2 = map(float, v)
                x1y1x2y2 = (x1, y1, x2, y2)
                break
            except Exception:
                pass

    if x1y1x2y2 is None and all(k in det for k in ("x1", "y1", "x2", "y2")):
        try:
            x1y1x2y2 = (float(det["x1"]), float(det["y1"]), float(det["x2"]), float(det["y2"]))
        except Exception:
            x1y1x2y2 = None

    if x1y1x2y2 is None and all(k in det for k in ("x", "y", "width", "height")):
        try:
            x = float(det["x"]); y = float(det["y"])
            w = float(det["width"]); h = float(det["height"])
            x1y1x2y2 = (x, y, x + w, y + h)
        except Exception:
            x1y1x2y2 = None

    if x1y1x2y2 is None:
        return None

    x1, y1, x2, y2 = x1y1x2y2
    bw = max(0.0, x2 - x1)
    bh = max(0.0, y2 - y1)
    if bw <= 0 or bh <= 0:
        return None

    mpp = _meters_per_pixel_webmercator(float(lat), int(zoom))
    area = float(bw) * float(bh) * (mpp ** 2)

    # limita outliers absurdos (bbox gigante)
    if area <= 0 or area > 10_000:
        return None
    return area


def _estimate_kw_from_detection(det: Dict[str, Any], default_kw: float) -> float:
    """
    Converte uma detecÃ§Ã£o em kW estimados.

    - Se tiver Ã¡rea mÂ² => kW â‰ˆ Ã¡rea_m2 * densidade_kW_m2 (proxy)
    - Ajuste por perfil (industrial/comercial pode ter arranjos mais densos)
    """
    lu = str(det.get("landuse") or "unknown").lower()

    # densidade mÃ©dia ~ 0.18 kW por mÂ² (â‰ˆ 1 kW ~ 5.5 mÂ²)
    # aplica um "cap" para nÃ£o explodir em bbox ruim
    area = _bbox_area_m2(det)
    if area is not None:
        dens = 0.18
        kw = area * dens
        kw = max(0.1, min(kw, 50.0))  # 0.1kW..50kW por bbox
    else:
        kw = float(default_kw)

    # multiplicadores conservadores por uso
    if lu == "industrial":
        kw *= 1.30
    elif lu == "commercial":
        kw *= 1.10
    elif lu == "residential":
        kw *= 0.95

    return float(kw)


# -----------------------------
# HeurÃ­sticas de carga (proxy)
# -----------------------------

_LOAD_KW_PER_DET = {
    "residencial": 3.0,   # kW "equivalente" por detecÃ§Ã£o (proxy)
    "comercial": 15.0,
    "industrial": 40.0,
}

def _estimate_peak_load_kw(contagem_por_tipo: Dict[str, int]) -> float:
    res = float(contagem_por_tipo.get("residencial", 0)) * _LOAD_KW_PER_DET["residencial"]
    com = float(contagem_por_tipo.get("comercial", 0)) * _LOAD_KW_PER_DET["comercial"]
    ind = float(contagem_por_tipo.get("industrial", 0)) * _LOAD_KW_PER_DET["industrial"]

    base = res + com + ind
    # diversidade / margem (proxy para pico)
    return max(1.0, base * 1.4)


def _classify_penetration(ratio: float) -> str:
    if ratio >= 0.30:
        return "ALTA"
    if ratio >= 0.15:
        return "MÃ‰DIA"
    return "BAIXA"


def _classify_duck_curve(pct_res: float, pen_ratio: float) -> str:
    # Duck curve Ã© mais crÃ­tica quando:
    # - residencial domina e
    # - penetraÃ§Ã£o Ã© relevante
    if pct_res >= 60 and pen_ratio >= 0.20:
        return "ALTO"
    if pct_res >= 40 and pen_ratio >= 0.10:
        return "MODERADO"
    return "BAIXO"


# -----------------------------
# API principal
# -----------------------------

def analisar_impacto_rede(
    contagem_por_tipo: Dict[str, int],
    total_paineis: int,
    joined: Optional[List[Dict[str, Any]]] = None,
    default_kw_per_detection: float = 0.45,
) -> Dict[str, Any]:
    """
    Retorna:
      - percentuais por perfil
      - estimativas: geraÃ§Ã£o_kw, carga_pico_kw, pen_ratio
      - classificaÃ§Ãµes: penetracao_mmgd e risco_duck_curve
    """
    total = sum(contagem_por_tipo.values()) or 1

    percentuais = {
        k: round((float(contagem_por_tipo.get(k, 0)) / float(total)) * 100.0, 1)
        for k in ["residencial", "industrial", "comercial"]
    }

    # potÃªncia estimada (kW)
    if joined:
        gen_kw = sum(_estimate_kw_from_detection(d, default_kw_per_detection) for d in joined)
        kw_avg = (gen_kw / max(1, len(joined)))
    else:
        gen_kw = float(total_paineis) * float(default_kw_per_detection)
        kw_avg = float(default_kw_per_detection)

    # carga estimada (kW)
    peak_load_kw = _estimate_peak_load_kw(contagem_por_tipo)

    pen_ratio = float(gen_kw) / float(peak_load_kw) if peak_load_kw > 0 else 0.0
    penetracao = _classify_penetration(pen_ratio)

    pct_res = float(percentuais.get("residencial", 0.0))
    risco_duck = _classify_duck_curve(pct_res, pen_ratio)

    recomendacoes = []
    if penetracao != "BAIXA":
        recomendacoes.append("Avaliar fluxo reverso e tensÃ£o no perÃ­odo solar (meio do dia).")
    if risco_duck != "BAIXO":
        recomendacoes.append("Simular curva de carga (duck curve) e checar rampa no fim da tarde.")
    recomendacoes.append("Priorizar inspeÃ§Ã£o em clusters com alta densidade de geraÃ§Ã£o estimada.")

    return {
        "risco_duck_curve": risco_duck,
        "penetracao_mmgd": penetracao,
        "percentuais": percentuais,
        "estimativas": {
            "geracao_kw": round(float(gen_kw), 1),
            "kw_medio_por_det": round(float(kw_avg), 2),
            "carga_pico_kw": round(float(peak_load_kw), 1),
            "penetracao_ratio": round(float(pen_ratio), 3),
        },
        "recomendacoes": recomendacoes,
    }


===== FILE: C:\Users\Home\Desktop\Nova pasta (5)\SolarScan-MVP\modules\entrada.py =====

from typing import List, Dict, Any, Union

def receber_requisicao(json_input: Union[List[Dict[str, Any]], Dict[str, Any]]) -> List[Dict[str, Any]]:
    # Aceita dict Ãºnico e converte para lista
    if isinstance(json_input, dict):
        json_input = [json_input]
    elif not isinstance(json_input, list):
        raise ValueError("O input deve ser uma lista de objetos JSON (ou um objeto Ãºnico).")

    if not json_input:
        raise ValueError("A lista de entrada estÃ¡ vazia.")

    required_keys = ("id", "lat", "lon")
    print(f"Validando {len(json_input)} subestaÃ§Ãµes...")

    for index, item in enumerate(json_input):
        if not isinstance(item, dict):
            raise ValueError(f"Item {index}: cada item deve ser um objeto JSON (dict).")

        missing = [k for k in required_keys if k not in item]
        if missing:
            raise ValueError(f"Item {index}: Campos obrigatÃ³rios faltando: {', '.join(missing)}")

        # id
        if not isinstance(item["id"], str):
            raise ValueError(f"Item {index}: 'id' deve ser string")
        item_id = item["id"].strip()
        if not item_id:
            raise ValueError(f"Item {index}: 'id' nÃ£o pode ser vazio")

        # lat (conversÃ£o separada da checagem de faixa)
        try:
            lat = float(item["lat"])
        except (TypeError, ValueError):
            raise ValueError(f"Item {index} ({item_id}): Latitude deve ser numÃ©rica")
        if not (-90.0 <= lat <= 90.0):
            raise ValueError(f"Item {index} ({item_id}): Latitude {lat} invÃ¡lida")

        # lon
        try:
            lon = float(item["lon"])
        except (TypeError, ValueError):
            raise ValueError(f"Item {index} ({item_id}): Longitude deve ser numÃ©rica")
        if not (-180.0 <= lon <= 180.0):
            raise ValueError(f"Item {index} ({item_id}): Longitude {lon} invÃ¡lida")

        # normaliza
        item["id"] = item_id
        item["lat"] = lat
        item["lon"] = lon

    print(f"Input validado com sucesso: {len(json_input)} ativos.")
    return json_input


===== FILE: C:\Users\Home\Desktop\Nova pasta (5)\SolarScan-MVP\modules\geo_calculos.py =====

import numpy as np
import math
from sklearn.neighbors import NearestNeighbors

from config import (
    RAIO_MINIMO_METROS, 
    RAIO_MAXIMO_METROS, 
    RAIO_PADRAO_METROS,
    RAIO_TERRA_METROS
)
# MÃ³dulo para cÃ¡lculos geoespaciais avanÃ§ados
def calcular_raios_dinamicos(lista_subestacoes: list) -> dict:

    qtd = len(lista_subestacoes)
    resultado_raios = {}
    
    # CASO 1: Apenas 1 subestaÃ§Ã£o (Sem vizinhos para comparar)
    if qtd < 2:
        print(" Apenas 1 subestaÃ§Ã£o detectada. Usando raio padrÃ£o.")
        for sub in lista_subestacoes:
            resultado_raios[sub["id"]] = RAIO_PADRAO_METROS
        return resultado_raios

    # CASO 2: MÃºltiplas subestaÃ§Ãµes (CÃ¡lculo Vetorial)
    print(f"Calculando densidade para {qtd} pontos...")

    # Extrair coordenadas e converter para Radianos (exigÃªncia do sklearn haversine)
    # Formato da matriz: [[lat_rad, lon_rad], [lat_rad, lon_rad], ...]
    coords_deg = np.array([[s['lat'], s['lon']] for s in lista_subestacoes])
    coords_rad = np.radians(coords_deg)

    # Configurar Modelo Nearest Neighbors
    # n_neighbors=2 porque o vizinho 1 Ã© o prÃ³prio ponto (distÃ¢ncia 0)
    vizinhos_proximos = NearestNeighbors(n_neighbors=2, algorithm='ball_tree', metric='haversine')
    vizinhos_proximos.fit(coords_rad)
    
    # Encontrar distÃ¢ncias (retorna em radianos)
    distances_rad, indices = vizinhos_proximos.kneighbors(coords_rad)
    
    # O array distances_rad tem shape (N, 2). A coluna 0 Ã© o prÃ³prio ponto, coluna 1 Ã© o vizinho.
    vizinho_dist_rad = distances_rad[:, 1]
    
    # Converter radianos para metros
    vizinho_dist_metros = vizinho_dist_rad * RAIO_TERRA_METROS

    # Iterar e aplicar regras de negÃ³cio (Travas)
    for i, sub in enumerate(lista_subestacoes):
        dist_vizinho = vizinho_dist_metros[i]
        
        # Raio Calculado: Metade da distÃ¢ncia ao vizinho mais prÃ³ximo
        raio_calculado = dist_vizinho / 2.0
        
        # AplicaÃ§Ã£o das Travas (Clamping)
        if raio_calculado < RAIO_MINIMO_METROS:
            raio_final = RAIO_MINIMO_METROS
        elif raio_calculado > RAIO_MAXIMO_METROS:
            raio_final = RAIO_MAXIMO_METROS
        else:
            raio_final = raio_calculado
            
        resultado_raios[sub["id"]] = round(raio_final, 2)

    return resultado_raios

# FunÃ§Ã£o para gerar uma grade de coordenadas cobrindo um cÃ­rculo
def gerar_grid_coordenadas(lat: float, long: float, raio: float) -> list:

    # Converter metros para graus (aproximaÃ§Ã£o na latitude)
    meters_per_degree = 111139.0   
    delta_lat = raio / meters_per_degree

    # CorreÃ§Ã£o da longitude baseada na latitude (cos)
    cos_lat = math.cos(math.radians(lat))
    if abs(cos_lat) < 1e-12:
        cos_lat = 1e-12

    delta_lon = raio / (meters_per_degree * cos_lat)
    
    # Grid 3x3 simples cobrindo o ROI
    grade = []
    
    # Passo de varredura (step) - define sobreposiÃ§Ã£o
    step_lat = delta_lat * 0.5
    step_lon = delta_lon * 0.5
    
    # Loop simples ao redor do centro
    for i in range(-1, 2):
        for j in range(-1, 2):
            lat_nova = lat + (i * step_lat)
            long_nova = long + (j * step_lon)
            grade.append((lat_nova, long_nova))
    return grade

import math
from typing import Any, Optional, Tuple

_R_WEBMERCATOR = 6378137.0  # metros

def _meters_per_pixel_webmercator(lat: float, zoom: int) -> float:
    return (math.cos(math.radians(lat)) * 2.0 * math.pi * _R_WEBMERCATOR) / (256.0 * (2.0 ** zoom))

def _mercator_from_latlon(lat: float, lon: float) -> Tuple[float, float]:
    x = _R_WEBMERCATOR * math.radians(lon)
    y = _R_WEBMERCATOR * math.log(math.tan(math.pi / 4.0 + math.radians(lat) / 2.0))
    return x, y

def _latlon_from_mercator(x: float, y: float) -> Tuple[float, float]:
    lon = math.degrees(x / _R_WEBMERCATOR)
    lat = math.degrees(2.0 * math.atan(math.exp(y / _R_WEBMERCATOR)) - math.pi / 2.0)
    return lat, lon

def _bbox_center_px(det: Any) -> Optional[Tuple[float, float]]:
    if not isinstance(det, dict):
        return None

    # formatos comuns com 4 valores
    for k in ("bbox", "xyxy", "box"):
        v = det.get(k)
        if isinstance(v, (list, tuple)) and len(v) == 4:
            x1, y1, x2, y2 = map(float, v)
            return (x1 + x2) / 2.0, (y1 + y2) / 2.0

    # formato centro + tamanho
    v = det.get("xywh")
    if isinstance(v, (list, tuple)) and len(v) == 4:
        cx, cy, _, _ = map(float, v)
        return cx, cy

    # formato com chaves explÃ­citas
    if all(k in det for k in ("x1", "y1", "x2", "y2")):
        x1 = float(det["x1"]); y1 = float(det["y1"])
        x2 = float(det["x2"]); y2 = float(det["y2"])
        return (x1 + x2) / 2.0, (y1 + y2) / 2.0

    # âœ… formato do seu YOLO (x, y, width, height) onde (x,y) Ã© canto superior esquerdo
    if all(k in det for k in ("x", "y", "width", "height")):
        x = float(det["x"]); y = float(det["y"])
        w = float(det["width"]); h = float(det["height"])
        return x + (w / 2.0), y + (h / 2.0)

    return None

def anexar_latlon_da_bbox(
    det: dict,
    tile_lat: float,
    tile_lon: float,
    zoom: int,
    img_w: int,
    img_h: int,
) -> bool:
    c = _bbox_center_px(det)
    if c is None:
        return False

    cx, cy = c
    mpp = _meters_per_pixel_webmercator(tile_lat, zoom)

    dx = (cx - (img_w / 2.0)) * mpp
    dy = (cy - (img_h / 2.0)) * mpp

    x0, y0 = _mercator_from_latlon(tile_lat, tile_lon)

    # y na imagem cresce pra baixo; no Mercator cresce pra cima
    lat, lon = _latlon_from_mercator(x0 + dx, y0 - dy)

    det["lat"] = float(lat)
    det["lon"] = float(lon)
    det["geo_fallback"] = "bbox_to_latlon"
    return True


===== FILE: C:\Users\Home\Desktop\Nova pasta (5)\SolarScan-MVP\modules\imagens.py =====

import os
import time
import random
import requests

try:
    import certifi
except Exception:
    certifi = None

"""
MÃ³dulo para aquisiÃ§Ã£o de imagens de satÃ©lite.

âš ï¸ Importante:
- NÃƒO hardcode API keys no cÃ³digo.
- Use GOOGLE_MAPS_API_KEY via variÃ¡vel de ambiente.
"""

GOOGLE_STATIC_MAPS_URL = "https://maps.googleapis.com/maps/api/staticmap"


def baixar_imagem_tile(
    lat: float,
    lon: float,
    zoom: int = 20,
    size: str = "640x640",
    scale: int = 2,
    img_format: str = "png",
    timeout_s: int = 20,
    retries: int = 3,
) -> bytes:
    """
    Baixa imagem de satÃ©lite do Google Maps Static API.

    Args:
        lat/lon: centro do tile
        zoom: zoom (deve ser consistente com geo_calculos.anexar_latlon_da_bbox)
        size: ex "640x640"
        scale: 1 ou 2
        img_format: "png" ou "jpg"
        timeout_s: timeout do request
        retries: tentativas com backoff para 429/5xx
    """
    api_key = "AIzaSyAHbiO3fZ-GUeg6g-Q53qyJnZ9Q0F_54Sc"
    if not api_key:
        raise RuntimeError("Defina a variÃ¡vel de ambiente GOOGLE_MAPS_API_KEY")

    params = {
        "center": f"{lat},{lon}",
        "zoom": str(int(zoom)),
        "size": size,
        "scale": str(int(scale)),
        "maptype": "satellite",
        "format": img_format,
        "key": api_key,
    }

    headers = {"User-Agent": "SolarScan/1.0 (+tile-downloader)"}

    # Em alguns ambientes Windows, isso resolve travas/erros de SSL no requests
    verify = certifi.where() if certifi is not None else True

    last_err = None
    for attempt in range(retries + 1):
        try:
            r = requests.get(
                GOOGLE_STATIC_MAPS_URL,
                params=params,
                headers=headers,
                timeout=timeout_s,
                verify=verify,
            )

            if r.status_code in (429, 500, 502, 503, 504):
                last_err = RuntimeError(f"HTTP {r.status_code}: {r.text[:200]}")
                if attempt < retries:
                    sleep_s = (0.8 * (2 ** attempt)) + random.random() * 0.25
                    time.sleep(sleep_s)
                    continue
                raise last_err

            if r.status_code != 200:
                raise RuntimeError(f"HTTP {r.status_code}: {r.text[:300]}")

            content_type = (r.headers.get("Content-Type") or "").lower()
            if "image" not in content_type:
                raise RuntimeError(
                    f"Resposta nÃ£o Ã© imagem. Content-Type={content_type}. Body={r.text[:300]}"
                )

            return r.content

        except Exception as e:
            last_err = e
            if attempt < retries:
                sleep_s = (0.8 * (2 ** attempt)) + random.random() * 0.25
                time.sleep(sleep_s)
                continue
            raise RuntimeError(
                f"Falha ao baixar tile ({lat},{lon}) zoom={zoom}: {e}"
            ) from e


===== FILE: C:\Users\Home\Desktop\Nova pasta (5)\SolarScan-MVP\modules\landuse_provider.py =====

# modules/landuse_provider.py
from __future__ import annotations

import json
import os
import logging
from dataclasses import dataclass
from functools import lru_cache
from pathlib import Path
from typing import Any, Callable, Dict, List, Optional, Tuple

from shapely.geometry import shape, box
from shapely.validation import make_valid

try:
    # Shapely 2.x
    from shapely.strtree import STRtree
except Exception:
    STRtree = None

from modules.rio_provider import is_inside_rio_bbox, query_rio_polygons
from modules.osm import obter_poligonos_osm

logger = logging.getLogger("solarscan.landuse")
if not logger.handlers:
    logger.setLevel(logging.INFO)
    h = logging.StreamHandler()
    h.setFormatter(logging.Formatter("%(asctime)s | %(levelname)s | %(message)s", "%H:%M:%S"))
    logger.addHandler(h)
    logger.propagate = False

BASE_DIR = Path(__file__).resolve().parent.parent

# -----------------------------------------------------------------------------
# Region detection (lightweight, no external APIs)
# -----------------------------------------------------------------------------
# Obs: sÃ£o bboxes aproximadas (estado inteiro). Servem sÃ³ para escolher provider.
STATE_BBOX = {
    "RJ": (-44.9, -23.4, -40.8, -20.7),
    "SP": (-53.1, -25.5, -44.0, -19.6),
    "MG": (-51.3, -23.2, -39.8, -13.8),
}

def _inside_bbox(lat: float, lon: float, bbox: Tuple[float, float, float, float]) -> bool:
    min_lon, min_lat, max_lon, max_lat = bbox
    return (min_lat <= float(lat) <= max_lat) and (min_lon <= float(lon) <= max_lon)

def detect_region(lat: float, lon: float, region_hint: Optional[str] = None) -> Optional[str]:
    """
    Retorna: "RJ"|"SP"|"MG"|None
    region_hint (se informado) vence a heurÃ­stica.
    """
    if region_hint:
        rh = str(region_hint).strip().upper()
        if rh in STATE_BBOX:
            return rh

    # RJ (municÃ­pio) tem detector mais preciso no rio_provider
    if is_inside_rio_bbox(lat, lon):
        return "RJ"

    for uf, bb in STATE_BBOX.items():
        if uf == "RJ":
            # RJ bbox amplo pode enganar; preferir o detector do municÃ­pio.
            continue
        if _inside_bbox(lat, lon, bb):
            return uf

    return None

# -----------------------------------------------------------------------------
# Generic GeoJSON provider (para SP/MG ou qualquer UF com GeoJSON local)
# -----------------------------------------------------------------------------

@dataclass(frozen=True)
class _GeoIndex:
    records: List[Dict[str, Any]]
    index: Any  # STRtree|None
    geoms: List[Any]

def _ensure_valid_geom(g: Any) -> Optional[Any]:
    try:
        if g is None or getattr(g, "is_empty", True):
            return None
        if not getattr(g, "is_valid", True):
            g = make_valid(g)
        gt = getattr(g, "geom_type", "")
        if gt not in ("Polygon", "MultiPolygon"):
            return None
        return g
    except Exception:
        return None

def _default_mapper(props: Dict[str, Any]) -> str:
    """
    Mapeamento genÃ©rico e conservador:
    - Se vier algo explicitamente classificado em propriedades, tenta usar.
    - Caso contrÃ¡rio: unknown.
    """
    p = props or {}
    # campos comuns em bases de uso do solo
    for key in ("landuse", "uso", "classe", "class", "tipo", "category", "categoria"):
        v = str(p.get(key) or "").strip().lower()
        if not v:
            continue
        if "res" in v or "morad" in v or "habita" in v:
            return "residential"
        if "ind" in v or "fabr" in v or "wareh" in v or "logist" in v:
            return "industrial"
        if "com" in v or "serv" in v or "shop" in v or "office" in v or "varej" in v:
            return "commercial"
    return "unknown"

@lru_cache(maxsize=8)
def _load_geojson_index(path: str, mapper_key: str) -> _GeoIndex:
    """
    Cacheia Ã­ndices por path+mapper_key (mapper_key muda quando env/mapeamento muda).
    """
    p = Path(path)
    if not p.exists():
        raise FileNotFoundError(f"GeoJSON nÃ£o encontrado: {p}")

    data = json.loads(p.read_text(encoding="utf-8"))
    feats = (data or {}).get("features", []) if isinstance(data, dict) else []
    if not isinstance(feats, list):
        feats = []

    records: List[Dict[str, Any]] = []
    geoms: List[Any] = []

    mapper = _default_mapper  # hoje: genÃ©rico. (pode plugar mapper especÃ­fico depois)

    for f in feats:
        if not isinstance(f, dict):
            continue
        geom = _ensure_valid_geom(shape((f.get("geometry") or {})))
        if geom is None:
            continue
        props = f.get("properties") or {}
        lu = mapper(props)
        records.append({"geometry": geom, "landuse": lu})
        geoms.append(geom)

    idx = None
    if STRtree is not None and geoms:
        try:
            idx = STRtree(geoms)
        except Exception:
            idx = None

    return _GeoIndex(records=records, index=idx, geoms=geoms)

def _make_query_bbox(lat: float, lon: float, radius_m: float) -> Tuple[float, float, float, float]:
    import math
    dlat = float(radius_m) / 111_320.0
    dlon = float(radius_m) / (111_320.0 * max(1e-6, math.cos(math.radians(float(lat)))))
    return (float(lon) - dlon, float(lat) - dlat, float(lon) + dlon, float(lat) + dlat)

def query_geojson_polygons(path: str, lat: float, lon: float, radius_m: float) -> List[Dict[str, Any]]:
    # mapper_key permite invalidar cache futuramente (ex: mapeamento custom por UF)
    mapper_key = "default"
    payload = _load_geojson_index(path, mapper_key)
    records = payload.records
    idx = payload.index
    geoms = payload.geoms

    qbbox = _make_query_bbox(lat, lon, radius_m)
    candidate_idxs: List[int] = []

    if idx is not None and STRtree is not None:
        try:
            hits = idx.query(box(*qbbox))
            if len(hits) > 0 and isinstance(hits[0], (int,)):
                candidate_idxs = [int(i) for i in hits]
            else:
                geom_to_i = {id(g): i for i, g in enumerate(geoms)}
                for g in hits:
                    i = geom_to_i.get(id(g))
                    if i is not None:
                        candidate_idxs.append(i)
        except Exception:
            candidate_idxs = []

    if not candidate_idxs:
        candidate_idxs = list(range(len(records)))

    out: List[Dict[str, Any]] = []
    for i in candidate_idxs:
        rec = records[i]
        try:
            # filtro rÃ¡pido por bbox
            gx1, gy1, gx2, gy2 = rec["geometry"].bounds
            minx, miny, maxx, maxy = qbbox
            if gx2 < minx or gx1 > maxx or gy2 < miny or gy1 > maxy:
                continue
        except Exception:
            pass
        out.append(rec)

    return out

# -----------------------------------------------------------------------------
# Factory pattern: escolhe provider (RJ GeoJSON / UF GeoJSON / OSM)
# -----------------------------------------------------------------------------

def _env_path(primary: str, fallbacks: List[str], default: Optional[str] = None) -> str:
    """
    Pega a primeira env que existir + nÃ£o vazia.
    """
    for k in [primary] + (fallbacks or []):
        v = os.getenv(k)
        if v and str(v).strip():
            return str(v).strip()
    return default or ""

DEFAULT_RIO_GEOJSON_PATH = _env_path(
    "RIO_USO_SOLO_GEOJSON",
    ["RIO_USO_GEOJSON"],
    str(BASE_DIR / "data" / "rio" / "USO_DO_SOLO_2019.geojson"),
)

DEFAULT_SP_GEOJSON_PATH = _env_path(
    "SP_USO_SOLO_GEOJSON",
    ["SP_USO_GEOJSON"],
    str(BASE_DIR / "data" / "sp" / "USO_SOLO_SP.geojson"),
)

DEFAULT_MG_GEOJSON_PATH = _env_path(
    "MG_USO_SOLO_GEOJSON",
    ["MG_USO_GEOJSON"],
    str(BASE_DIR / "data" / "mg" / "USO_SOLO_MG.geojson"),
)

def get_landuse_polygons(
    lat: float,
    lon: float,
    radius_m: float,
    region_hint: Optional[str] = None,
    rio_geojson_path: Optional[str] = None,
    sp_geojson_path: Optional[str] = None,
    mg_geojson_path: Optional[str] = None,
) -> Dict[str, Any]:
    """
    Factory: detecta UF/regiÃ£o e escolhe provider.

    Cadeia:
      1) RJ (MunicÃ­pio do Rio): DATA.RIO (GeoJSON local) se existir
      2) SP: GeoJSON local se existir
      3) MG: GeoJSON local se existir
      4) Fallback nacional: OSM melhorado
    """
    region = detect_region(lat, lon, region_hint=region_hint)

    # RJ (MunicÃ­pio do Rio) - provider especÃ­fico com mapping confiÃ¡vel
    if region == "RJ":
        rio_path = rio_geojson_path or DEFAULT_RIO_GEOJSON_PATH
        if Path(rio_path).exists():
            try:
                polys = query_rio_polygons(rio_path, lat, lon, radius_m) or []
                if polys:
                    return {"polygons": polys, "success": True, "provider": "DATA.RIO", "region": "RJ", "source_path": rio_path}

                osm = obter_poligonos_osm(lat, lon, radius_m)
                osm["provider"] = "OSM"
                osm["region"] = "RJ"
                osm["fallback_reason"] = "DATA.RIO vazio (sem match)"
                return osm
            except Exception as e:
                osm = obter_poligonos_osm(lat, lon, radius_m)
                osm["provider"] = "OSM"
                osm["region"] = "RJ"
                osm["fallback_reason"] = f"DATA.RIO falhou: {e}"
                return osm

        osm = obter_poligonos_osm(lat, lon, radius_m)
        osm["provider"] = "OSM"
        osm["region"] = "RJ"
        osm["fallback_reason"] = f"DATA.RIO ausente em {rio_path}"
        return osm

    # SP
    if region == "SP":
        sp_path = sp_geojson_path or DEFAULT_SP_GEOJSON_PATH
        if Path(sp_path).exists():
            try:
                polys = query_geojson_polygons(sp_path, lat, lon, radius_m) or []
                if polys:
                    return {"polygons": polys, "success": True, "provider": "GEOJSON_SP", "region": "SP", "source_path": sp_path}
            except Exception as e:
                logger.warning("SP provider falhou | %s", str(e))

    # MG
    if region == "MG":
        mg_path = mg_geojson_path or DEFAULT_MG_GEOJSON_PATH
        if Path(mg_path).exists():
            try:
                polys = query_geojson_polygons(mg_path, lat, lon, radius_m) or []
                if polys:
                    return {"polygons": polys, "success": True, "provider": "GEOJSON_MG", "region": "MG", "source_path": mg_path}
            except Exception as e:
                logger.warning("MG provider falhou | %s", str(e))

    # Nacional: OSM
    osm = obter_poligonos_osm(lat, lon, radius_m)
    osm["provider"] = "OSM"
    osm["region"] = region or "BR"
    if region in ("SP", "MG"):
        osm["fallback_reason"] = "GeoJSON estadual ausente/sem match"
    return osm


===== FILE: C:\Users\Home\Desktop\Nova pasta (5)\SolarScan-MVP\modules\osm.py =====

# modules/osm.py
"""
ContextualizaÃ§Ã£o territorial via OpenStreetMap (OSM)

SaÃ­da (compatÃ­vel com spatial_join.py):
[
  {"geometry": shapely.geometry.Polygon|MultiPolygon, "landuse": "residential|commercial|industrial|unknown"},
  ...
]

Upgrades:
- Consulta mais sinais alÃ©m de landuse:
  building:use, usage, craft, service, tourism, leisure, shop, office, amenity, industrial, power, man_made
- NormalizaÃ§Ã£o mais agressiva para reduzir unknown (com heurÃ­sticas conservadoras)
"""

from __future__ import annotations

import time
import math
import logging
from typing import Any, Dict, List, Optional, Tuple

import requests
import certifi
from requests.exceptions import RequestException, SSLError

from shapely.geometry import Polygon, Point
from shapely.validation import make_valid
from shapely.affinity import scale


# --------------------------------------------------------------------------- #
# Tuning
# --------------------------------------------------------------------------- #

MIN_CLASSIFIED_POLYGONS = 10
UNKNOWN_RATIO_THRESHOLD = 0.70
POI_BUFFER_M = 25.0
MERGE_FALLBACK = True


logger = logging.getLogger("solarscan.osm")
if not logger.handlers:
    logger.setLevel(logging.INFO)
    handler = logging.StreamHandler()
    handler.setFormatter(logging.Formatter("%(asctime)s | %(levelname)s | %(message)s", "%H:%M:%S"))
    logger.addHandler(handler)
    logger.propagate = False


_overpass_env = "https://overpass.kumi.systems/api/interpreter"

OVERPASS_ENDPOINTS: List[str] = [
    _overpass_env,
    "https://overpass-api.de/api/interpreter",
    "https://overpass.kumi.systems/api/interpreter",
    "https://overpass.nchc.org.tw/api/interpreter",
]
OVERPASS_ENDPOINTS = [u for u in OVERPASS_ENDPOINTS if u]


def _build_overpass_query_landuse(lat: float, lon: float, raio_m: float) -> str:
    r = int(max(1.0, float(raio_m)))
    return f"""
    [out:json][timeout:25];
    (
      way["landuse"](around:{r},{lat},{lon});
      relation["landuse"](around:{r},{lat},{lon});
    );
    out geom;
    """


def _build_overpass_query_fallback(lat: float, lon: float, raio_m: float) -> str:
    r = int(max(1.0, float(raio_m)))
    return f"""
    [out:json][timeout:25];
    (
      way["building"](around:{r},{lat},{lon});
      relation["building"](around:{r},{lat},{lon});

      way["building:use"](around:{r},{lat},{lon});
      relation["building:use"](around:{r},{lat},{lon});

      way["usage"](around:{r},{lat},{lon});
      relation["usage"](around:{r},{lat},{lon});

      node["shop"](around:{r},{lat},{lon});
      way["shop"](around:{r},{lat},{lon});
      relation["shop"](around:{r},{lat},{lon});

      node["office"](around:{r},{lat},{lon});
      way["office"](around:{r},{lat},{lon});
      relation["office"](around:{r},{lat},{lon});

      node["amenity"](around:{r},{lat},{lon});
      way["amenity"](around:{r},{lat},{lon});
      relation["amenity"](around:{r},{lat},{lon});

      node["craft"](around:{r},{lat},{lon});
      way["craft"](around:{r},{lat},{lon});
      relation["craft"](around:{r},{lat},{lon});

      node["service"](around:{r},{lat},{lon});
      way["service"](around:{r},{lat},{lon});
      relation["service"](around:{r},{lat},{lon});

      node["tourism"](around:{r},{lat},{lon});
      way["tourism"](around:{r},{lat},{lon});
      relation["tourism"](around:{r},{lat},{lon});

      node["leisure"](around:{r},{lat},{lon});
      way["leisure"](around:{r},{lat},{lon});
      relation["leisure"](around:{r},{lat},{lon});

      node["industrial"](around:{r},{lat},{lon});
      way["industrial"](around:{r},{lat},{lon});
      relation["industrial"](around:{r},{lat},{lon});

      node["man_made"="works"](around:{r},{lat},{lon});
      way["man_made"="works"](around:{r},{lat},{lon});
      relation["man_made"="works"](around:{r},{lat},{lon});

      node["power"](around:{r},{lat},{lon});
      way["power"](around:{r},{lat},{lon});
      relation["power"](around:{r},{lat},{lon});
    );
    out geom;
    """


def _post_overpass(query: str) -> Dict[str, Any]:
    last_err: Optional[Exception] = None

    for url in OVERPASS_ENDPOINTS:
        for attempt in range(1, 4):
            try:
                logger.info("OSM | tentando endpoint=%s (tentativa %d/3)", url, attempt)

                resp = requests.post(
                    url,
                    data={"data": query},
                    headers={"User-Agent": "SolarScan/1.0 (requests)"},
                    timeout=(10, 60),
                    verify=certifi.where(),
                )
                resp.raise_for_status()
                return resp.json()

            except SSLError as e:
                last_err = e
                logger.warning("OSM | SSL falhou no endpoint=%s | %s", url, str(e))
                break
            except ValueError as e:
                last_err = e
                logger.warning("OSM | JSON invÃ¡lido endpoint=%s | %s", url, str(e))
                time.sleep(0.5 * attempt)
            except RequestException as e:
                last_err = e
                logger.warning("OSM | request falhou endpoint=%s | %s", url, str(e))
                time.sleep(0.6 * attempt)

    raise RuntimeError(f"Overpass API error: {last_err}")


def _coords_from_geometry(geom_list: Any) -> Optional[List[Tuple[float, float]]]:
    if not isinstance(geom_list, list) or len(geom_list) < 3:
        return None

    coords: List[Tuple[float, float]] = []
    for p in geom_list:
        if not isinstance(p, dict) or "lat" not in p or "lon" not in p:
            continue
        coords.append((float(p["lon"]), float(p["lat"])))

    if len(coords) < 3:
        return None
    if coords[0] != coords[-1]:
        coords.append(coords[0])
    if len(coords) < 4:
        return None
    return coords


def _safe_make_polygon(coords: List[Tuple[float, float]]):
    try:
        poly = Polygon(coords)
        if poly.is_empty:
            return None
        if not poly.is_valid:
            poly = make_valid(poly)
        if getattr(poly, "geom_type", None) not in ("Polygon", "MultiPolygon"):
            return None
        return poly
    except Exception:
        return None


def _buffer_node_as_polygon(lat: float, lon: float, radius_m: float):
    try:
        dlat = float(radius_m) / 111_320.0
        dlon = float(radius_m) / (111_320.0 * max(1e-6, math.cos(math.radians(float(lat)))))

        circ = Point(float(lon), float(lat)).buffer(1.0, resolution=16)
        poly = scale(circ, xfact=dlon, yfact=dlat, origin=(float(lon), float(lat)))

        if not poly.is_valid:
            poly = make_valid(poly)
        if getattr(poly, "geom_type", None) not in ("Polygon", "MultiPolygon"):
            return None
        return poly
    except Exception:
        return None


_LANDUSE_TO_CLASS = {
    "residential": "residential",
    "house": "residential",

    "commercial": "commercial",
    "retail": "commercial",

    "industrial": "industrial",
    "construction": "industrial",
    "brownfield": "industrial",
    "quarry": "industrial",
}

_RES_BUILDINGS = {
    "house", "apartments", "residential", "terrace", "semidetached_house",
    "bungalow", "detached", "dormitory",
    "garage", "garages", "shed", "hut",
}
_COM_BUILDINGS = {"commercial", "retail", "office", "supermarket", "kiosk"}
_IND_BUILDINGS = {"industrial", "warehouse", "factory", "manufacture"}

_COM_USAGE = {"commercial", "retail", "office", "services", "service"}
_IND_USAGE = {"industrial", "warehouse", "logistics", "manufacturing"}
_RES_USAGE = {"residential", "apartments", "house", "housing"}

_AMENITY_EXCEPT_UNKNOWN = {"grave_yard", "cemetery", "shelter"}


def _normalize_from_tags(tags: Dict[str, Any]) -> str:
    t: Dict[str, str] = {}
    for k, v in (tags or {}).items():
        try:
            t[str(k)] = str(v)
        except Exception:
            continue

    lu = (t.get("landuse") or "").strip().lower()
    if lu:
        return _LANDUSE_TO_CLASS.get(lu, "unknown")

    p = (t.get("power") or "").strip().lower()
    if p in {"substation", "plant", "generator"}:
        return "industrial"
    if (t.get("man_made") or "").strip().lower() == "works":
        return "industrial"
    if "industrial" in t:
        return "industrial"

    bu = (t.get("building:use") or "").strip().lower()
    if bu in _IND_USAGE:
        return "industrial"
    if bu in _COM_USAGE:
        return "commercial"
    if bu in _RES_USAGE:
        return "residential"

    us = (t.get("usage") or "").strip().lower()
    if us in _IND_USAGE:
        return "industrial"
    if us in _COM_USAGE:
        return "commercial"
    if us in _RES_USAGE:
        return "residential"

    b = (t.get("building") or "").strip().lower()
    if b in _IND_BUILDINGS:
        return "industrial"
    if b in _COM_BUILDINGS:
        return "commercial"
    if b in _RES_BUILDINGS:
        return "residential"

    if any(k in t for k in ("craft", "service", "shop", "office", "tourism", "leisure")):
        return "commercial"

    if "amenity" in t:
        a = (t.get("amenity") or "").strip().lower()
        if a and a in _AMENITY_EXCEPT_UNKNOWN:
            return "unknown"
        return "commercial"

    if b in {"yes", "building"}:
        if any(k.startswith("addr:") for k in t.keys()):
            return "residential"
        return "residential"

    if any(v.strip().lower() in {"warehouse", "construction"} for v in t.values()):
        return "industrial"

    return "unknown"


def _count_classes(polygons: List[Dict[str, Any]]) -> Dict[str, int]:
    c = {"residential": 0, "commercial": 0, "industrial": 0, "unknown": 0}
    for p in polygons or []:
        k = str(p.get("landuse", "unknown"))
        if k not in c:
            k = "unknown"
        c[k] += 1
    return c


def parse_polygons_landuse(data: Dict[str, Any]) -> List[Dict[str, Any]]:
    elements = (data or {}).get("elements", [])
    if not isinstance(elements, list):
        return []

    polygons: List[Dict[str, Any]] = []
    for el in elements:
        if not isinstance(el, dict):
            continue
        tags = el.get("tags") or {}
        if not isinstance(tags, dict):
            tags = {}

        coords = _coords_from_geometry(el.get("geometry"))
        if not coords:
            continue

        poly = _safe_make_polygon(coords)
        if poly is None:
            continue

        cls = _normalize_from_tags(tags)
        polygons.append({"geometry": poly, "landuse": cls})

    return polygons


def parse_polygons_fallback(data: Dict[str, Any], poi_buffer_m: float = POI_BUFFER_M) -> List[Dict[str, Any]]:
    elements = (data or {}).get("elements", [])
    if not isinstance(elements, list):
        return []

    polygons: List[Dict[str, Any]] = []
    for el in elements:
        if not isinstance(el, dict):
            continue

        tags = el.get("tags") or {}
        if not isinstance(tags, dict):
            tags = {}

        cls = _normalize_from_tags(tags)

        coords = _coords_from_geometry(el.get("geometry"))
        if coords:
            poly = _safe_make_polygon(coords)
            if poly is not None:
                polygons.append({"geometry": poly, "landuse": cls})
                continue

        if el.get("type") == "node" and "lat" in el and "lon" in el:
            poly = _buffer_node_as_polygon(float(el["lat"]), float(el["lon"]), float(poi_buffer_m))
            if poly is not None:
                polygons.append({"geometry": poly, "landuse": cls})

    return polygons


def obter_poligonos_osm(lat: float, lon: float, raio_m: float) -> Dict[str, Any]:
    logger.info("OSM | consulta iniciada (raio=%.0fm)", float(raio_m))

    try:
        data = _post_overpass(_build_overpass_query_landuse(lat, lon, raio_m))
        polygons = parse_polygons_landuse(data)

        counts = _count_classes(polygons)
        classified = counts["residential"] + counts["commercial"] + counts["industrial"]
        total = int(len(polygons))
        unknown_ratio = (float(counts.get("unknown", 0)) / float(total)) if total else 1.0

        logger.info(
            "OSM | landuse normalizado | total=%d | res=%d com=%d ind=%d unk=%d",
            len(polygons), counts["residential"], counts["commercial"], counts["industrial"], counts["unknown"]
        )
        logger.info("OSM | unknown_ratio=%.2f", unknown_ratio)

        need_fallback = (classified < MIN_CLASSIFIED_POLYGONS) or (unknown_ratio >= UNKNOWN_RATIO_THRESHOLD)
        if need_fallback:
            reason = []
            if classified < MIN_CLASSIFIED_POLYGONS:
                reason.append(f"classes Ãºteis baixas ({classified} < {MIN_CLASSIFIED_POLYGONS})")
            if unknown_ratio >= UNKNOWN_RATIO_THRESHOLD:
                reason.append(f"unknown alto ({unknown_ratio:.0%} >= {UNKNOWN_RATIO_THRESHOLD:.0%})")

            logger.info("OSM | ativando fallback buildings/POIs | %s", " + ".join(reason))
            data_fb = _post_overpass(_build_overpass_query_fallback(lat, lon, raio_m))
            fb_polys = parse_polygons_fallback(data_fb, poi_buffer_m=POI_BUFFER_M)

            if MERGE_FALLBACK:
                polygons = polygons + fb_polys
            else:
                polygons = fb_polys

        logger.info("OSM | polÃ­gonos vÃ¡lidos=%d", len(polygons))
        return {"polygons": polygons, "success": True}

    except Exception as e:
        err = str(e)
        logger.warning("OSM | falhou: %s", err)
        return {"polygons": [], "success": False, "error": err}


===== FILE: C:\Users\Home\Desktop\Nova pasta (5)\SolarScan-MVP\modules\rio_provider.py =====

# modules/rio_provider.py
from __future__ import annotations

import json
from dataclasses import dataclass
from functools import lru_cache
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple

from shapely.geometry import shape
from shapely.validation import make_valid

try:
    # Shapely 2.x
    from shapely.strtree import STRtree
except Exception:
    STRtree = None


@dataclass(frozen=True)
class PolygonRecord:
    geometry: Any  # shapely geometry
    landuse: str   # "residential|commercial|industrial|unknown"


# bbox aproximada do MunicÃ­pio do Rio de Janeiro (WGS84, lon/lat)
RIO_BBOX = (-43.80, -23.10, -43.05, -22.75)  # (min_lon, min_lat, max_lon, max_lat)


def _safe_kind(x: Any) -> str:
    return str(x or "").strip().lower()

def map_rio_kind(properties: Dict[str, Any]) -> str:
    """
    Mapeamento EXATO baseado nos valores Ãºnicos do GeoJSON DATA.RIO (USO_DO_SOLO_2019).
    Corrige problemas onde Ã¡reas residenciais caiam em default/commercial.
    """
    p = properties or {}
    
    # ObtÃ©m o valor cru e normaliza (minusculo e sem espaÃ§os extras)
    # Ex: "Ãreas residenciais" -> "Ã¡reas residenciais"
    uso_original = str(p.get("usoagregad") or "").strip().lower()
    
    # DicionÃ¡rio de Mapeamento Direto (De -> Para)
    MAPPING = {
        # --- RESIDENCIAL ---
        "Ã¡reas residenciais": "residential",
        "favela": "residential",
        
        # --- COMERCIAL / SERVIÃ‡OS / INSTITUCIONAL ---
        # Escolas, hospitais, shoppings, prÃ©dios pÃºblicos tÃªm perfil de carga comercial
        "Ã¡reas de comÃ©rcio e serviÃ§os": "commercial",
        "Ã¡reas de educaÃ§Ã£o e saÃºde": "commercial",
        "Ã¡reas institucionais e de infraestrutura pÃºblica": "commercial",
        "Ã¡reas de lazer": "commercial", # Clubes, estÃ¡dios, parques urbanos com edificaÃ§Ãµes
        
        # --- INDUSTRIAL / INFRAESTRUTURA PESADA ---
        "Ã¡reas industriais": "industrial",
        "Ã¡reas de exploraÃ§Ã£o mineral": "industrial", # Pedreiras
        "Ã¡reas de transporte": "industrial", # Portos, aeroportos, terminais de Ã´nibus, garagens
        
        # --- DESCONHECIDO / NÃƒO URBANO (Ignorar na detecÃ§Ã£o ou tratar com cautela) ---
        "Ã¡reas nÃ£o edificadas": "unknown", # Terrenos baldios (pode ter casa, mas oficial Ã© vazio)
        "Ã¡reas agrÃ­colas": "unknown",
        "afloramentos rochosos e depÃ³sitos sedimentares": "unknown",
        "cobertura arbÃ³rea e arbustiva": "unknown",
        "cobertura gramÃ­neo lenhosa": "unknown",
        "corpos hÃ­dricos": "unknown",
        "Ã¡reas sujeitas Ã  inundaÃ§Ã£o": "unknown"
    }

    # 1. Tenta o match exato
    if uso_original in MAPPING:
        return MAPPING[uso_original]

    # 2. Fallback de seguranÃ§a (caso apareÃ§a uma string nova no futuro)
    # Se contiver "residencial" ou "favela" no nome, forÃ§a residencial
    if "residencial" in uso_original or "favela" in uso_original:
        return "residential"
    
    if "industrial" in uso_original or "indÃºstria" in uso_original:
        return "industrial"

    # Se o grupo for "Ã¡reas urbanizadas" mas nÃ£o sabemos o uso,
    # "unknown" Ã© mais seguro que "commercial" para nÃ£o enviesar a estatÃ­stica
    grupo = str(p.get("grupo") or "").strip().lower()
    if "urbanizadas" in grupo:
        return "unknown" 

    return "unknown"


def _ensure_valid_geom(g: Any) -> Optional[Any]:
    try:
        if g is None or getattr(g, "is_empty", True):
            return None
        if not getattr(g, "is_valid", True):
            g = make_valid(g)
        gt = getattr(g, "geom_type", "")
        if gt not in ("Polygon", "MultiPolygon"):
            return None
        return g
    except Exception:
        return None


def _intersects_bbox(geom: Any, bbox: Tuple[float, float, float, float]) -> bool:
    try:
        minx, miny, maxx, maxy = bbox
        gx1, gy1, gx2, gy2 = geom.bounds
        return not (gx2 < minx or gx1 > maxx or gy2 < miny or gy1 > maxy)
    except Exception:
        return False


def _make_query_bbox(lat: float, lon: float, radius_m: float) -> Tuple[float, float, float, float]:
    import math
    dlat = float(radius_m) / 111_320.0
    dlon = float(radius_m) / (111_320.0 * max(1e-6, math.cos(math.radians(float(lat)))))
    return (float(lon) - dlon, float(lat) - dlat, float(lon) + dlon, float(lat) + dlat)


@lru_cache(maxsize=1)
def load_rio_polygons(path: str) -> Dict[str, Any]:
    """
    Carrega GeoJSON e retorna:
      {"records": [...], "index": STRtree|None, "geoms": [...]}
    """
    p = Path(path)
    if not p.exists():
        raise FileNotFoundError(f"GeoJSON nÃ£o encontrado: {p}")

    data = json.loads(p.read_text(encoding="utf-8"))
    feats = (data or {}).get("features", []) if isinstance(data, dict) else []
    if not isinstance(feats, list):
        feats = []

    records: List[PolygonRecord] = []
    geoms: List[Any] = []

    for f in feats:
        if not isinstance(f, dict):
            continue
        geom = _ensure_valid_geom(shape((f.get("geometry") or {})))
        if geom is None:
            continue

        props = f.get("properties") or {}
        kind = map_rio_kind(props)
        rec = PolygonRecord(geometry=geom, landuse=kind)
        records.append(rec)
        geoms.append(geom)

    idx = None
    if STRtree is not None and geoms:
        try:
            idx = STRtree(geoms)
        except Exception:
            idx = None

    return {"records": records, "index": idx, "geoms": geoms}


def query_rio_polygons(path: str, lat: float, lon: float, radius_m: float) -> List[Dict[str, Any]]:
    payload = load_rio_polygons(path)
    records: List[PolygonRecord] = payload["records"]
    idx = payload["index"]
    geoms = payload["geoms"]

    qbbox = _make_query_bbox(lat, lon, radius_m)

    candidate_idxs: List[int] = []

    if idx is not None and STRtree is not None:
        try:
            from shapely.geometry import box
            hits = idx.query(box(*qbbox))

            # âœ… Shapely pode retornar:
            # - lista/ndarray de Ã­ndices (int)
            # - lista de geometrias
            if len(hits) > 0 and isinstance(hits[0], (int,)):
                candidate_idxs = [int(i) for i in hits]
            else:
                geom_to_i = {id(g): i for i, g in enumerate(geoms)}
                for g in hits:
                    i = geom_to_i.get(id(g))
                    if i is not None:
                        candidate_idxs.append(i)

        except Exception:
            candidate_idxs = []

    # âœ… Se o Ã­ndice falhar (ou retornar vazio), faz fallback pro scan bbox
    if not candidate_idxs:
        candidate_idxs = list(range(len(records)))

    out: List[Dict[str, Any]] = []
    for i in candidate_idxs:
        rec = records[i]
        if _intersects_bbox(rec.geometry, qbbox):
            out.append({"geometry": rec.geometry, "landuse": rec.landuse})

    return out


def is_inside_rio_bbox(lat: float, lon: float) -> bool:
    min_lon, min_lat, max_lon, max_lat = RIO_BBOX
    return (min_lat <= float(lat) <= max_lat) and (min_lon <= float(lon) <= max_lon)


===== FILE: C:\Users\Home\Desktop\Nova pasta (5)\SolarScan-MVP\modules\saida.py =====

from datetime import datetime, timezone
"""

from datetime import datetime, timezone
MÃ³dulo para formataÃ§Ã£o do output final.
"""

def formatar_output(id_subestacao: str, lat: float, lon: float,
                    contagem_por_tipo: dict, impacto: dict, 
                    total_paineis: int) -> dict:
    """
    Formata os dados no schema padrÃ£o da API SolarScan.
    
    Args:
        id_subestacao: ID da subestaÃ§Ã£o
        lat: Latitude
        lon: Longitude
        contagem_por_tipo: Contagem de painÃ©is por tipo
        impacto: DicionÃ¡rio com anÃ¡lise de impacto
        total_paineis: Total de painÃ©is detectados
        
    Returns:
        dict: Output formatado conforme especificaÃ§Ã£o
    """
    # TODO: Ajustar para corresponder exatamente Ã  especificaÃ§Ã£o do documento
    
    # Determinar perfil predominante
    if total_paineis == 0:
        perfil_predominante = "INDEFINIDO"
    else:
        # Encontrar tipo com maior contagem
        perfil_predominante = max(contagem_por_tipo.items(), 
                                  key=lambda x: x[1])[0].upper()
    
    output = {
        "id_subestacao": id_subestacao,
        "latitude_sub": round(lat, 6),
        "longitude_sub": round(lon, 6),
        "perfil_predominante": perfil_predominante,
        "%_residencial": impacto.get("percentuais", {}).get("residencial", 0),
        "%_industrial": impacto.get("percentuais", {}).get("industrial", 0),
        "%_comercial": impacto.get("percentuais", {}).get("comercial", 0),
        "qnt_aprox_placa": total_paineis,
        "penetracao_mmgd": impacto.get("penetracao_mmgd", "INDEFINIDO"),
        "risco_duck_curve": impacto.get("risco_duck_curve", "INDEFINIDO"),
        "timestamp_processamento": datetime.now(timezone.utc).isoformat().replace("+00:00", "Z"),
        "versao_pipeline": "1.0.0-mvp"
    }
    
    return output


===== FILE: C:\Users\Home\Desktop\Nova pasta (5)\SolarScan-MVP\modules\spatial_join.py =====

# modules/spatial_join.py
from __future__ import annotations

import math
from shapely.geometry import Point

try:
    from shapely.prepared import prep
except Exception:
    prep = None


_PRIORITY = {"industrial": 3, "commercial": 2, "residential": 1, "unknown": 0}


def _deg_to_meters_lat(d: float) -> float:
    return float(d) * 111_320.0


def _distance_deg_to_m(d_deg: float, lat: float) -> float:
    # aproximaÃ§Ã£o em metros (bom o bastante pra 30â€“60m)
    return _deg_to_meters_lat(d_deg)


def spatial_join(
    detections: list[dict],
    polygons: list[dict],
    max_near_m: float = 60.0,
) -> list[dict]:
    """
    Faz join ponto->polÃ­gono.

    - PrimÃ¡rio: contÃ©m/intersecta => confidence=HIGH
    - Fallback: polÃ­gono mais prÃ³ximo atÃ© max_near_m => confidence=LOW
    """
    if prep is not None:
        prepared = [(prep(p["geometry"]), p["geometry"], str(p.get("landuse", "unknown"))) for p in (polygons or [])]
        use_prepared = True
    else:
        prepared = [(p["geometry"], p["geometry"], str(p.get("landuse", "unknown"))) for p in (polygons or [])]
        use_prepared = False

    result = []

    for det in detections or []:
        pt = Point(det["lon"], det["lat"])

        best = "unknown"
        best_score = 0
        conf = "HIGH"

        hit_any = False
        for geom_pre, geom_raw, lu in prepared:
            hit = (geom_pre.contains(pt) or geom_pre.intersects(pt)) if use_prepared else geom_raw.covers(pt)
            if not hit:
                continue
            hit_any = True

            score = _PRIORITY.get(lu, 0)
            if score > best_score:
                best, best_score = lu, score
                if best_score == 3:
                    break

        if not hit_any and prepared:
            nearest_lu = "unknown"
            nearest_score = 0
            nearest_m = None

            for _, geom_raw, lu in prepared:
                try:
                    d_deg = geom_raw.distance(pt)
                    d_m = _distance_deg_to_m(d_deg, det["lat"])
                except Exception:
                    continue

                if d_m <= float(max_near_m):
                    score = _PRIORITY.get(lu, 0)
                    if (score > nearest_score) or (score == nearest_score and (nearest_m is None or d_m < nearest_m)):
                        nearest_score = score
                        nearest_lu = lu
                        nearest_m = d_m

            if nearest_m is not None and nearest_score > 0:
                det2 = {**det, "landuse": nearest_lu, "landuse_confidence": "LOW", "landuse_near_m": round(float(nearest_m), 1)}
                result.append(det2)
                continue

        result.append({**det, "landuse": best, "landuse_confidence": conf})

    return result


def aggregate_landuse(joined: list[dict]) -> dict:
    summary = {}
    for item in joined or []:
        k = str(item.get("landuse", "unknown"))
        summary[k] = summary.get(k, 0) + 1
    return summary


===== FILE: C:\Users\Home\Desktop\Nova pasta (5)\SolarScan-MVP\modules\__init__.py =====



